Unary and binary operators.
Figment provides an infinite number of operators. Tokens that start with an operator character are assumed to be operators. Some operator characters, such as (), [], and {}, have assumed
grouping pairs. For sanity's sake, you can't mismatch them.

By convention, a prefix unary : quotes things. However, this meaning isn't universal; it is still an operator, which means that other quotation forms are active.

3 + 4           / The + is an operator
3 + 4 / 5       / The + and / are both operators; + binds first
3 + 4 * 5       / Same here, but * instead of /
3+4/5           / Binary / applied to binary + applied to 3 and 4, and 5
3+4 / 5         / Plus binds first
3/4 + 5         / Divide binds first
3/ 4 + 5        / Postfix (/ applied to 3) joined with 4, plus 5

3 +' 4          - Binary +' applied to 3 and 4
3 --' 4         - Binary --' applied to 3 and 4

foo+bar         - Binary + applied to foo and bar
foo*bar         - Binary * applied to foo and bar
foo-bar         - Exceptional case: identifier foo-bar
foo/bar         - Exceptional case: identifier foo/bar
foo/-bar        - Binary /- applied to foo and bar
foo-/bar        - Binary -/ applied to foo and bar
foo--bar        - Binary -- applied to foo and bar
foo//bar        - Binary // applied to foo and bar

foo-            - Postfix unary - applied to foo
foo/            - Postfix unary / applied to foo
-foo            - Prefix unary - applied to foo
/bar            - Prefix unary / applied to bar

3 + :4          / Three plus prefix : applied to 4
%3 + --5        / Unary % applied to 3, plus unary -- applied to 5 (it's up to the backend to decide whether this is semantically valid)
^&2 + ~~qr/foo/ / Unary ^& applied to 2, plus unary ~~ applied to the quoted regexp foo
^!@qr+foo+      / Unary ^!@ applied to the quoted regexp foo

$foo            / Unary $ applied to foo
foo $bar        / Foo joined with unary $ applied to bar
foo$bar         / Binary $ applied to foo and bar
$(bar)          / Prefix unary $ applied to () applied to bar
$$(bar)         / Prefix unary $$ applied to () applied to bar

+\@{bif}        / Prefix unary +\@ applied to {} applied to bif

! \x -> 100     / Binary -> applied to unary ! applied to unary \ applied to x and 100
! \x y z -> 5   / Binary -> applied to (unary ! applied to ((unary \ applied to x) join y join z)) and 5

x:xs ++ y       / Binary ++ applied to binary : applied to x and xs, and y
x : xs++y       / Binary : applied to x and binary ++ applied to xs and y

3 + {foo}       / Three plus {} applied to foo
3 + [foo]       / Three plus [] applied to foo
3 + (foo)       / Three plus () applied to foo (parens aren't erased, though the convention is to make them the identity function)

3(foo)          / Three joined with () applied to foo
3[foo]          / Three joined with [] applied to foo
3{foo}          / Three joined with {} applied to foo

()              / Brackets contain an empty expression node (still valid though)
[]              / Ditto
{}              / Ditto

[foo][bar]      / Foo inside brackets joined with bar inside brackets

3 + 4(foo)      / Join binds more tightly than plus
3 +4(foo)       / Parse tree is (join 3 (unary+ (join 4 (paren foo))))
3 + 4 (foo)     / Join still binds first
3 +4 (foo)      / Joins 3 to +4, and that to () applied to foo

3? + 50         / Postfix ? applied to 3, plus 50
3 ? +50         / Binary ? applied to 3 and prefix + applied to 50
3 ? 4 : 5       / Binary ? applied to 3 and binary : applied to 4 and 5
foo: bar        / Postfix : applied to foo, joined with bar
foo : bar       / Binary : applied to foo and bar
foo:bar         / Binary : applied to foo and bar

b /t[x] /f[y]   / S-expression is (join (join b (unary/ (join t ([] x)))) (unary/ (join f ([] y))))
b t[x] f[y]     / S-expression is (join (join b (join t ([] x))) (join f ([] y)))

int x = 5       / S-expression is (= (join int x) 5)
int x = 5, y    / S-expression is (, (= (join int x) 5) y)

foo.bar         / Binary . applied to foo and bar
foo. bar        / Postfix . applied to foo, joined with bar
foo .bar        / Foo joined with prefix . applied to bar

foo.            / Postfix . applied to foo, joined with bar
bar

foo::bar        / Binary :: applied to foo and bar
foo:: bar       / Postfix unary :: applied to foo, joined with bar
foo: :bar       / Postfix unary : applied to foo, joined with quoted word bar
foo: : :bar     / Binary : applied to postfix unary : applied to foo, and quoted word bar
foo: : : bar    / Ditto

qs+foo+ + 4     / Binary +
qs+foo++ 4      / Postfix unary + and join
qs(foo)+ 4      / Ditto
qs/foo/+ 4      / Ditto
qs/foo/ + 4     / Binary +

foo, bar, bif   / Exceptional case: comma is always left-associative binary, and it separates other operators
foo+,+bar       / Postfix + applied to foo, comma prefix + applied to bar
foo,            / Invalid: expected expression for comma

3 // 4          / Binary // applied to 3 and 4
3 || 4          / Binary || applied to 3 and 4
3 /| 4          / Binary /| applied to 3 and 4
3 |\ 4          / Binary |\ applied to 3 and 4
3 \\ 4          / Binary \\ applied to 3 and 4
3 -> 4          / Binary -> applied to 3 and 4
3 <-> 4         / Binary <-> applied to 3 and 4
3 <=> 4         / Binary <=> applied to 3 and 4
3 /|\ 4         / Binary /|\ applied to 3 and 4
3 \|/ 4         / Binary \|/ applied to 3 and 4

: 3+4           / Prefix : applied to (3 + 4)
:  3 + 4        / Prefix : applied to 3, plus 4 (the distinction is space/not-space rather than number of spaces)
: 3 + 4         / Ditto
: 3+ 4          / Prefix : applied to ((postfix + applied to 3) join 4)
: 3 +4          / Prefix : applied to (3 join prefix + applied to 4)

3 ^ 4           / Binary ^ applied to 3 and 4
3 V 4           / Exceptional case: binary V applied to 3 and 4
3 U 4           / Exceptional case: binary U applied to 3 and 4
f O g           / Exceptional case: binary O applied to f and g
                / In fact, all uppercase letters are operators. The only limitation is that you can't put one after a /, since that would start a comment.

foo@bar.com                             / Binary @ applied to foo and binary . applied to bar and com
http://foo.com                          / Binary :// applied to http and binary . applied to foo and com
http://foo.com:8080/bif/baz.jpg         / S-expression is (:// http (/ (/ (: (. foo com) 8080) bif) (. baz jpg)))
/usr/share/bin                          / S-expression is (/ (/ (unary/ usr) share) bin)
