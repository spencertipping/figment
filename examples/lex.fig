Comments.

This paragraph is a comment.
Figment embeds SDoc syntax to provide easy large-block commenting.

Line comments start with / followed by a capitalized word; for example:

/ This is a line comment

Also, capital letters are reserved in the sense that you can't start identifiers with them.

Atoms and surface syntax.

'string literal'        / A literal string
"string literal"        / Another literal string (no difference between single/double quotes)
qq'string literal'      / Another way to quote stuff
qq"string literal"      / Ditto

foo'                    / Exceptional case: identifier foo' (e.g. let foo = 5, foo' = foo + 1 in ...)
foo''                   / Exceptional case: identifier foo''
foo-bar                 / Exceptional case: identifier foo-bar

:quoted-word            / A quoted word (by convention, a prefix : quotes something; but this is semantic rather than syntactic)
qq quoted-word          / Another way to say it, but with stronger binding

3.141592                / A floating-point number
3                       / An integer
-3                      / Unary negation, then an integer

qn 3.141592             / A way to quote a number (though why bother, really)
qn 3                    / Another quoted number
qn -3                   / Forces the - to be a part of the number, rather than being applied later as an operator

true                    / Identifier true

Quoted forms.
When matching brackets are used as delimiters, braces within the quoted text will be matched.

qr[^foo$]               / Regular expression
qr/^foo$/               / Regular expression
qs[foo (bar) [bif]]     / Quoted syntax
qs/foo (bar) bif/       / Quoted syntax
qs'foo bar bif'         / Quoted syntax

qfoobar''               / Not necessarily defined, but syntactically valid
qfoobar()               / Ditto

qFoobar''               / Same as above, but no unquoting
qFoobar()               / Ditto

Delimiters.
q is a reserved letter. This means that identifiers can't start with q, though they can contain it.

qr[^foo$]
qr(^foo$)
qr{^foo$}
qr/^foo$/
qr'^foo$'
qr"^foo$"
qr+^foo$+
qr|^foo$|
qr ^foo$                / Space is the delimiter

Unquoting.
Quoting is done with q, so unquoting is done with Q:

'string literal Q(4 + 5)'       / Becomes 'string literal 9', assuming sensible definition of numeric +
qs[(foo) bar Q[bif]]            / Becomes a syntax tree representing (foo) <join> bar <join> whatever bif is
'string literal Qfoo'           / No unquoting here; Q must be followed by a delimiter
'string literal Q foo '         / Unquoting, equivalent to Q(foo)
'string literal \Q foo '        / No unquoting, since Q is escaped

Unquoting can be prevented by using an unquote-proof quotation form. These are upper-cased:

qS[foo [bar] Q(bif)]            / Becomes a syntax tree representing foo <join> [bar] <join> Q(bif) -- no interpolation
qR[^fooQ(bif)$]                 / No interpolation here
